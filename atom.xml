<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GWesley&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gwesley.tk/"/>
  <updated>2016-12-26T07:59:45.000Z</updated>
  <id>http://gwesley.tk/</id>
  
  <author>
    <name>GWesley</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github Page 自定义域名开启 HTTPS</title>
    <link href="http://gwesley.tk/2016/12/26/https/"/>
    <id>http://gwesley.tk/2016/12/26/https/</id>
    <published>2016-12-26T03:28:00.000Z</published>
    <updated>2016-12-26T07:59:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>有不少人在使用 Github Pages 搭建自己的博客，不过 Github Pages 目前暂时还不支持自定义域名开启HTTPS，不过幸运的是有一些第三方的服务可以很简单的做到这一点。</p>
<p>Cloudflare 是一家提供 DNS 和 CDN 服务的公司，你可以简单把他理解为国外的 DNSPod，我们可以使用他们的免费服务 <code>免证书</code> 开启自己博客域名的 HTTPS 访问。</p>
<p>###步骤如下:</p>
<ol>
<li><p>首先去自己域名提供方的站点，修改 Nameservers 为：</p>
<ul>
<li>LEAH.NS.CLOUDFLARE.COM </li>
<li>ZEUS.NS.CLOUDFLARE.COM</li>
</ul>
<p>(未来可能修改，具体地址以 Cloudflare 官网提供的地址为准)</p>
</li>
</ol>
<ol>
<li><p>登陆 <a href="https://www.cloudflare.com" target="_blank" rel="external">Cloudflare 官网</a></p>
<p>进入顶部的 <code>Crypto</code> 选项，在这里我们选择 <code>FULL</code></p>
<p><img src="https://blog.cloudflare.com/content/images/2016/06/T08btVu.png" alt=""></p>
</li>
</ol>
<p>​    进入顶部的 <code>Page Rules</code> 选项，点击<code>Create Page Rule</code> 新建页面规则</p>
<p>​    </p>
<p>​    先创建第一条规则，强制使用HTTPS</p>
<p>  <img src="http://ww1.sinaimg.cn/large/5ff914a8jw1fb48vci14fj218u0pyjv1.jpg" alt="">        </p>
<p>​    再创建第二条规则，转发 <code>www</code> 开头的请求</p>
<p>  <img src="http://ww1.sinaimg.cn/large/5ff914a8jw1fb48za1ntlj21900sk789.jpg" alt=""></p>
<p>​    </p>
<p>DONE ! </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有不少人在使用 Github Pages 搭建自己的博客，不过 Github Pages 目前暂时还不支持自定义域名开启HTTPS，不过幸运的是有一些第三方的服务可以很简单的做到这一点。&lt;/p&gt;
&lt;p&gt;Cloudflare 是一家提供 DNS 和 CDN 服务的公司，你可以
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://gwesley.tk/2016/12/22/new_file_extention/"/>
    <id>http://gwesley.tk/2016/12/22/new_file_extention/</id>
    <published>2016-12-22T08:22:39.000Z</published>
    <updated>2016-12-22T08:23:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>title: NSCalendar Additions<br>author: Nate Cook<br>translator: GWesley<br>tags: iOS<br>excerpt: “ <code>NSCalendar</code> 已经悄悄的构建了大量的方法方便大家获取和操作日期。 从全新的日期组件存取与日期比较方法，到强大的日期插值与枚举方法，有太多的东西被我们忽视了。接下来让我们抽点时间来了解一下吧。”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;title: NSCalendar Additions&lt;br&gt;author: Nate Cook&lt;br&gt;translator: GWesley&lt;br&gt;tags: iOS&lt;br&gt;excerpt: “ &lt;code&gt;NSCalendar&lt;/code&gt; 已经悄悄的构建了大量的方法方
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NSCalendar Additions</title>
    <link href="http://gwesley.tk/2016/12/20/nscalendar_addition/"/>
    <id>http://gwesley.tk/2016/12/20/nscalendar_addition/</id>
    <published>2016-12-20T07:53:14.000Z</published>
    <updated>2016-12-20T08:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>日期.</em> 一个很普通的时间和它的实现间往往有着巨大的差异，里面隐藏的多方面的复杂性远超其它数据类型。其中包括亚秒级的精度，重叠单元，不同地理位置的时区边界，语言和语法上的本地化差异，以及为了夏令时的转换和闰年调整，而在标准时间中添加删除整块的时间等等，里面有太多的东西需要进行处理。</p>
<p>在开始进行任何重度日期相关的任务前，我们有必要深入了解一下我们手中已有的工具。相比写上上千个版本的 <code>dateIsTomorrow</code>，我觉得更好的办法是使用 <code>Foundation</code> 方法。你有在用 <code>NSDateComponents</code> 吗？你有指定正确的日历单元吗？你的代码在 2100 年 2 月 28 号还能正常工作么？</p>
<p>但事实上：大家一直都在使用那些已经非常熟悉了的 APIs 。除非你跑去考察版本说明和 API 变动表，不然你肯定不会知道最近发布的几个 OS X 版本里，<code>NSCalendar</code> 已经添加了一系列功能十分强大的方法去操作计算日期，最近的一次发布让我们可以在 iOS 中使用这些方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> calendar = <span class="type">NSCalendar</span>.currentCalendar()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSCalendar *calendar = [NSCalendar currentCalendar];</div></pre></td></tr></table></figure>
<p>从全新的日期组件存取与日期比较方法，到强大的日期插值与枚举方法，有太多的东西被我们忽视了。接下来让我们抽点时间来了解一下吧。</p>
<h2 id="便利的日期组件存取"><a href="#便利的日期组件存取" class="headerlink" title="便利的日期组件存取"></a>便利的日期组件存取</h2><p>哇, <code>NSDateComponents</code> 真是既实用又灵活，但当我只是想知道间隔的小时数时，它用起来感觉又太麻烦了。不要慌， <code>NSCalendar</code> 来救你了！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> hour = calendar.component(.<span class="type">CalendarUnitHour</span>, fromDate: <span class="type">NSDate</span>())</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSInteger hour = [calendar component:NSCalendarUnitHour fromDate:[NSDate date]];</div></pre></td></tr></table></figure>
<p>这样就好多了。<code>NSCalendar</code>，你还有哪些本事？</p>
<blockquote>
<ul>
<li><code>getEra(_:year:month:day:fromDate:)</code>：根据传入的日期引用返回纪元，年，月，日。不需要的参数可以传入 <code>nil</code>/<code>NULL</code>。 </li>
<li><code>getEra(_:yearForWeekOfYear:weekOfYear:weekday:fromDate:)</code>: 根据传入的日期引用返回纪元，年，当年第几周，星期几。不需要的参数可以传入 <code>nil</code>/<code>NULL</code>。</li>
<li><code>getHour(_:minute:second:nanosecond:fromDate:)</code>: 根据传入的日期引用返回时间信息，然后 <code>nil</code>/<code>NULL</code> 巴拉巴拉, 你懂的。</li>
</ul>
</blockquote>
<p><code>NSDateComponents</code>，刚才我是逗你玩呢，我收回前面吐槽你的话。下面还有不少属于你的方法：</p>
<blockquote>
<ul>
<li><code>componentsInTimeZone(_:fromDate:)</code>: 根据传入的的日期和时区返回一个 <code>NSDateComponents</code> 实例。</li>
<li><code>components(_:fromDateComponents:toDateComponents:options:)</code>: 返回两个 <code>NSDateComponents</code> 实例间的差异。如果有未赋值的组件，该方法会使用默认值，所以我们传入的实例至少得设置了年属性。options参数暂时没有用，传 <code>nil</code>/<code>0</code> 就行。</li>
</ul>
</blockquote>
<h2 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h2><p>虽然直接比较 <code>NSDate</code> 是件挺简单的事，但一些更有意义的比较可能变得惊人的复杂。两个 <code>NSDate</code> 实例是同一天？同一小时？亦或是同一周？</p>
<p>现在没必要发愁了，<code>NSCalendar</code> 提供了大量的比较方法：</p>
<blockquote>
<ul>
<li><code>isDateInToday(_:)</code>: 如果传入的日期是当天返回 <code>true</code> 。</li>
<li><code>isDateInTomorrow(_:)</code>: 如果传入的日期是明天返回 <code>true</code> 。</li>
<li><code>isDateInYesterday(_:)</code>: 如果传入的日期是昨天返回 <code>true</code> 。</li>
<li><code>isDateInWeekend(_:)</code>: 如果传入的日期是周末返回 <code>true</code> 。</li>
<li><code>isDate(_:inSameDayAsDate:)</code>: 如果两个 <code>NSDate</code> 实例在同一天返回 <code>true</code> - 没必要再去获取日期部件进行比较了。</li>
<li><code>isDate(_:equalToDate:toUnitGranularity:)</code>: 如果传入的日期在同一指定单位内返回 <code>true</code> 。这意味着，两个在同一周的日期实例调用 <code>calendar.isDate(tuesday, equalToDate: thursday, toUnitGranularity: .CalendarUnitWeekOfYear)</code> 方法时会返回 <code>true</code> ，就算他们不在同一个月也是如此。</li>
<li><code>compareDate(_:toDate:toUnitGranularity:)</code>: 返回一个 <code>NSComparisonResult</code>，当做和任何指定区间内的日期相等。</li>
<li><code>date(_:matchesComponents:)</code>: 如果日期匹配指定的部件返回 <code>true</code> 。</li>
</ul>
</blockquote>
<h2 id="日期插值"><a href="#日期插值" class="headerlink" title="日期插值"></a>日期插值</h2><p>接下来讲一些根据起始点寻找下一个日期的方法。你可以基于一个 <code>NSDateComponents</code> 实例，一个指定的日期组件，或者特定的时分秒，去找到下一个（或上一个）日期。所有这些方法都需要一个 <code>NSCalendarOptions</code> 位参数去提供更加精细的控制，特别是一开始我们没能找到准确的匹配的时候，它可以帮我们确定如何选定下一个日期。</p>
<h3 id="NSCalendarOptions"><a href="#NSCalendarOptions" class="headerlink" title="NSCalendarOptions"></a><code>NSCalendarOptions</code></h3><p>最简单的 <code>NSCalendarOptions</code> 选项是 <code>.SearchBackwards</code>，使用它我们可以在所有方法中进行反向搜索。反向搜索和正向搜索得到的结果是类似的。举个例子，反向搜索 11 之前的一个 <code>小时</code> 会给你返回 11：00， 而不是 11：59， 虽然在反向搜索中 11：59 严格意义上来讲是比 11：00 “早”。确实，反向搜索咋一看是符合直觉的，但想多了很可能会把你绕进去。既然 <code>.SearchBackwards</code> 是已经是最简单的选项，你大概能才猜到后面都是些什么鬼。</p>
<p>接下来的 <code>NSCalendarOptions</code> 选项能够帮助我们处理那些 “消失” 的时间。举个最直观的例子来说，当你进行一个短时窗搜索时碰到夏令时调整，时间提前了一个小时。或者搜索时遇到类似 2 月 或者 4 月 31 号，它都能帮我们跳过这些缺失的时间。</p>
<p>当遇到缺失的时间时，如果我们设置了 <code>NSCalendarOptions.MatchStrictly</code>，相关方法会根据传入的组件寻找一个 <code>精确</code> 的匹配。如果没有设置的话，那么必须提供 <code>.MatchNextTime</code>, <code>.MatchNextTimePreservingSmallerUnits</code>, 和  <code>.MatchPreviousTimePreservingSmallerUnits</code> 中的任一项。这些选项决定了如何处理我们请求时遇到的时间缺失问题。</p>
<p>这种情况，往往一例胜千言：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 2015 年情人节，早上 9 点</span></div><div class="line"><span class="keyword">let</span> valentines = cal.dateWithEra(<span class="number">1</span>, year: <span class="number">2015</span>, month: <span class="number">2</span>, day: <span class="number">14</span>, hour: <span class="number">9</span>, minute: <span class="number">0</span>, second: <span class="number">0</span>, nanosecond: <span class="number">0</span>)!</div><div class="line"></div><div class="line"><span class="comment">// 为了找到月的最后一天， 我设置一个日期组件然后把 `day` 设成 31：</span></div><div class="line"><span class="keyword">let</span> components = <span class="type">NSDateComponents</span>()</div><div class="line">components.day = <span class="number">31</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDate *valentines = [calendar dateWithEra:1 year:2015 month:2 day:14 hour:9 minute:0 second:0 nanosecond:0];</div><div class="line">    </div><div class="line">NSDateComponents *components = [[NSDateComponents alloc] init];</div><div class="line">components.day = 31;</div></pre></td></tr></table></figure>
<p>使用精确匹配会在三月找到下个 <code>31</code> 号，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar.nextDateAfterDate(valentines, matchingComponents: components, options: .<span class="type">MatchStrictly</span>)</div><div class="line"><span class="comment">// Mar 31, 2015, 12:00 AM</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSDate *date = [calendar nextDateAfterDate:valentines matchingComponents:components options:NSCalendarMatchStrictly];</div><div class="line">// Mar 31, 2015, 12:00 AM</div></pre></td></tr></table></figure>
<p>不使用精确匹配的话，<code>nextDateAfterDate</code> 方法会在找到匹配的指定天数前就在二月底停了下来，然后在下个月继续寻找。 可见，你所提供的选项决定了最终返回的具体日期。举例来说，使用  <code>.MatchNextTime</code> 选项找到下一个合适的日子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar.nextDateAfterDate(valentines, matchingComponents: components, options: .<span class="type">MatchNextTime</span>)</div><div class="line"><span class="comment">// Mar 1, 2015, 12:00 AM</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">date = [calendar nextDateAfterDate:valentines matchingComponents:components options:NSCalendarMatchNextTime];</div><div class="line">// Mar 1, 2015, 12:00 AM</div></pre></td></tr></table></figure>
<p>类似的，当使用 <code>.MatchNextTimePreservingSmallerUnits</code> 选项时会找到下一天，但是所有比指定单元 <code>NSCalendarUnitDay</code> 要小的单元会被保留下来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar.nextDateAfterDate(valentines, matchingComponents: components, options: .<span class="type">MatchNextTimePreservingSmallerUnits</span>)</div><div class="line"><span class="comment">// Mar 1, 2015, 9:00 AM</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">date = [calendar nextDateAfterDate:valentines matchingComponents:components options:NSCalendarMatchNextTimePreservingSmallerUnits];</div><div class="line">// Mar 1, 2015, 9:00 AM</div></pre></td></tr></table></figure>
<p>最后， 使用 <code>.MatchPreviousTimePreservingSmallerUnits</code> 选项会在 <em>另一个</em> 方向上解决缺失的时间问题， 和前面一样，保留较小的单元，然后找到匹配的前一天：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">calendar.nextDateAfterDate(valentines, matchingComponents: components, options: .<span class="type">MatchPreviousTimePreservingSmallerUnits</span>)</div><div class="line"><span class="comment">// Feb 28, 2015, 9:00 AM</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">date = [calendar nextDateAfterDate:valentines matchingComponents:components options:NSCalendarMatchPreviousTimePreservingSmallerUnits];</div><div class="line">// Feb 28, 2015, 9:00 AM</div></pre></td></tr></table></figure>
<p>除了这里的 <code>NDateComponents</code> 外，还值得注意的是 <code>nextDateAfterDate</code> 方法有两种变化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匹配指定的日历单元</span></div><div class="line">cal.nextDateAfterDate(valentines, matchingUnit: .<span class="type">CalendarUnitDay</span>, value: <span class="number">31</span>, options: .<span class="type">MatchStrictly</span>)</div><div class="line"><span class="comment">// March 31, 2015, 12:00 AM</span></div><div class="line"></div><div class="line"><span class="comment">// 匹配时，分，秒</span></div><div class="line">cal.nextDateAfterDate(valentines, matchingHour: <span class="number">15</span>, minute: <span class="number">30</span>, second: <span class="number">0</span>, options: .<span class="type">MatchNextTime</span>)</div><div class="line"><span class="comment">// Feb 14, 2015, 3:30 PM</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 匹配指定的日历单元</div><div class="line">date = [calendar nextDateAfterDate:valentines matchingUnit:NSCalendarUnitDay value:31 options:NSCalendarMatchStrictly];</div><div class="line">// March 31, 2015, 12:00 AM</div><div class="line">    </div><div class="line">// 匹配时，分，秒</div><div class="line">date = [calendar nextDateAfterDate:valentines matchingHour:15 minute:30 second:0 options:NSCalendarMatchNextTime];</div><div class="line">// Feb 14, 2015, 3:30 PM</div></pre></td></tr></table></figure>
<h3 id="枚举插值日期"><a href="#枚举插值日期" class="headerlink" title="枚举插值日期"></a>枚举插值日期</h3><p><code>NSCalendar</code> 提供了一个API去枚举日期， 所以大家没有必要反复的调用 <code>nextDateAfterDate</code> 方法。<code>enumerateDatesStartingAfterDate(_:matchingComponents:options:usingBlock:)</code> 方法根据提供的日期组件和选项，依次获取匹配的日期。可以将 <code>stop</code> 属性设为 <code>true</code> 去停止枚举。 </p>
<p>来试试这个 <code>NSCalendarOptions</code> 的新方法吧，下面展示了一种获取随后50个闰年的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> leapYearComponents = <span class="type">NSDateComponents</span>()</div><div class="line">leapYearComponents.month = <span class="number">2</span></div><div class="line">leapYearComponents.day = <span class="number">29</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> dateCount = <span class="number">0</span></div><div class="line">cal.enumerateDatesStartingAfterDate(<span class="type">NSDate</span>(), matchingComponents: leapYearComponents, options: .<span class="type">MatchStrictly</span> | .<span class="type">SearchBackwards</span>) </div><div class="line">&#123; (date: <span class="type">NSDate</span>!, exactMatch: <span class="type">Bool</span>, stop: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">ObjCBool</span>&gt;) <span class="keyword">in</span></div><div class="line">    <span class="built_in">println</span>(date)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ++dateCount == <span class="number">50</span> &#123;</div><div class="line">        <span class="comment">// .memory 用来获取一个 UnsafeMutablePointer 属性的值</span></div><div class="line">        stop.memory = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2012-02-29 05:00:00 +0000</span></div><div class="line"><span class="comment">// 2008-02-29 05:00:00 +0000</span></div><div class="line"><span class="comment">// 2004-02-29 05:00:00 +0000</span></div><div class="line"><span class="comment">// 2000-02-29 05:00:00 +0000</span></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NSDateComponents *leapYearComponents = [[NSDateComponents alloc] init];</div><div class="line">leapYearComponents.month = 2;</div><div class="line">leapYearComponents.day = 29;</div><div class="line">    </div><div class="line">__block int dateCount = 0;</div><div class="line">[calendar enumerateDatesStartingAfterDate:[NSDate date]</div><div class="line">                      matchingComponents:leapYearComponents</div><div class="line">                                 options:NSCalendarMatchStrictly | NSCalendarSearchBackwards</div><div class="line">                              usingBlock:^(NSDate *date, BOOL exactMatch, BOOL *stop) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, date);</div><div class="line">    if (++dateCount == 50) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line">// 2012-02-29 05:00:00 +0000</div><div class="line">// 2008-02-29 05:00:00 +0000</div><div class="line">// 2004-02-29 05:00:00 +0000</div><div class="line">// 2000-02-29 05:00:00 +0000</div><div class="line">// ...</div></pre></td></tr></table></figure>
<h3 id="处理周末"><a href="#处理周末" class="headerlink" title="处理周末"></a>处理周末</h3><p>要想找周末的话，记住下面两个 <code>NSCalendar</code> 方法就行：</p>
<blockquote>
<ul>
<li><code>nextWeekendStartDate(_:interval:options:afterDate)</code>: 根据传入的前两个参数返回下个周末的开始时间个长度。如果当前的地区和日历未提供对周末属性的支持，该方法会返回 <code>false</code> 。唯一相关的属性是 <code>.SearchBackwards</code>。（例子在下面。）</li>
<li><code>rangeOfWeekendStartDate(_:interval:containingDate)</code>: 根据传入的前两个参数返回 <em>包含</em> 该日期的周末。如果传入的日期并不在周末或者当前的地区和日历未提供对周末属性的支持，该方法会返回 <code>false</code> 。</li>
</ul>
</blockquote>
<h2 id="本地化日期符号"><a href="#本地化日期符号" class="headerlink" title="本地化日期符号"></a>本地化日期符号</h2><p>似乎所有这些新功能还不够丰富似的， <code>NSCalendar</code> 还提供了一整套的本地化日期符号，用来快速获取月份名称，星期名称等等。每组符号都列举在两个轴上：(1) 符号的长度  (2) 它是作为标准名称还是日期的一部分。</p>
<p>理解这两个属性对本地化来说十分的重要，有些语言，特别是斯拉夫语言，会依据不同的内容使用不同的名词格。举例来说，一个日期要使用某个 <code>standaloneMonthSymbols</code> 的变体作为头，而不是使用 <code>monthSymbols</code> 去格式化日期。</p>
<p>下面这张表包含了 <code>NSCalendar</code> 提供的所有符号，供大家阅览，请注意俄语列中独立符号的不同之处：</p>
<table>
<thead>
<tr>
<th>&nbsp;</th>
<th>en_US</th>
<th>ru_RU</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>monthSymbols</code></td>
<td>January, February, March…</td>
<td>января, февраля, марта…</td>
</tr>
<tr>
<td><code>shortMonthSymbols</code></td>
<td>Jan, Feb, Mar…</td>
<td>янв., февр., марта…</td>
</tr>
<tr>
<td><code>veryShortMonthSymbols</code></td>
<td>J, F, M, A…</td>
<td>Я, Ф, М, А…</td>
</tr>
<tr>
<td><code>standaloneMonthSymbols</code></td>
<td>January, February, March…</td>
<td>Январь, Февраль, Март…</td>
</tr>
<tr>
<td><code>shortStandaloneMonthSymbols</code></td>
<td>Jan, Feb, Mar…</td>
<td>Янв., Февр., Март…</td>
</tr>
<tr>
<td><code>veryShortStandaloneMonthSymbols</code></td>
<td>J, F, M, A…</td>
<td>Я, Ф, М, А…</td>
</tr>
<tr>
<td><code>weekdaySymbols</code></td>
<td>Sunday, Monday, Tuesday, Wednesday…</td>
<td>воскресенье, понедельник, вторник, среда…</td>
</tr>
<tr>
<td><code>shortWeekdaySymbols</code></td>
<td>Sun, Mon, Tue, Wed…</td>
<td>вс, пн, вт, ср…</td>
</tr>
<tr>
<td><code>veryShortWeekdaySymbols</code></td>
<td>S, M, T, W…</td>
<td>вс, пн, вт, ср…</td>
</tr>
<tr>
<td><code>standaloneWeekdaySymbols</code></td>
<td>Sunday, Monday, Tuesday, Wednesday…</td>
<td>Воскресенье, Понедельник, Вторник, Среда…</td>
</tr>
<tr>
<td><code>shortStandaloneWeekdaySymbols</code></td>
<td>Sun, Mon, Tue, Wed…</td>
<td>Вс, Пн, Вт, Ср…</td>
</tr>
<tr>
<td><code>veryShortStandaloneWeekdaySymbols</code></td>
<td>S, M, T, W…</td>
<td>В, П, В, С…</td>
</tr>
<tr>
<td><code>AMSymbol</code></td>
<td>AM</td>
<td>AM</td>
</tr>
<tr>
<td><code>PMSymbol</code></td>
<td>PM</td>
<td>PM</td>
</tr>
<tr>
<td><code>quarterSymbols</code></td>
<td>1st quarter, 2nd quarter, 3rd quarter, 4th quarter</td>
<td>1-й квартал, 2-й квартал, 3-й квартал, 4-й квартал</td>
</tr>
<tr>
<td><code>shortQuarterSymbols</code></td>
<td>Q1, Q2, Q3, Q4</td>
<td>1-й кв., 2-й кв., 3-й кв., 4-й кв.</td>
</tr>
<tr>
<td><code>standaloneQuarterSymbols</code></td>
<td>1st quarter, 2nd quarter, 3rd quarter, 4th quarter</td>
<td>1-й квартал, 2-й квартал, 3-й квартал, 4-й квартал</td>
</tr>
<tr>
<td><code>shortStandaloneQuarterSymbols</code></td>
<td>Q1, Q2, Q3, Q4</td>
<td>1-й кв., 2-й кв., 3-й кв., 4-й кв.</td>
</tr>
<tr>
<td><code>eraSymbols</code></td>
<td>BC, AD</td>
<td>до н. э., н. э.</td>
</tr>
<tr>
<td><code>longEraSymbols</code></td>
<td>Before Christ, Anno Domini</td>
<td>до н.э., н.э.</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em>注：</em> 这些符号在 <code>NSDateFormatter</code> 中也可以使用。</p>
</blockquote>
<h2 id="你的每周Swift化"><a href="#你的每周Swift化" class="headerlink" title="你的每周Swift化"></a>你的每周Swift化</h2><p>在 NSHipster 我们讨论 API 的时候会有一些 Swift 的版本，这渐渐变成了我们的特色。 甚至是在讨论这些全新的 <code>NSCalendar</code> API的时候，我们需要把前面的方法再打磨一下，将 <code>UnsafeMutablePointer</code> 参数替换为更符合语言习惯的元组返回值。</p>
<p>这里给大家介绍一个非常好用的 <code>NSCalendar</code> 扩展集（<a href="https://gist.github.com/natecook1000/43976a66fa04e3fdb3c7" target="_blank" rel="external"> 点 我 </a>），有了它我们使用访问日期组件和搜索周末方法时，可以不用把值传进又传出。比如，获取指定的日期组件就变得简单的多：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// built-in</span></div><div class="line"><span class="keyword">var</span> hour = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> minute = <span class="number">0</span></div><div class="line">calendar.getHour(&amp;hour, minute: &amp;minute, second: <span class="literal">nil</span>, nanosecond: <span class="literal">nil</span>, fromDate: <span class="type">NSDate</span>())</div><div class="line"></div><div class="line"><span class="comment">// Swift化</span></div><div class="line"><span class="keyword">let</span> (hour, minute, <span class="number">_</span>, <span class="number">_</span>) = calendar.getTimeFromDate(<span class="type">NSDate</span>())</div></pre></td></tr></table></figure>
<p>获取下一个周末的日期范围：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// built-in</span></div><div class="line"><span class="keyword">var</span> startDate: <span class="type">NSDate</span>?</div><div class="line"><span class="keyword">var</span> interval: <span class="type">NSTimeInterval</span> = <span class="number">0</span></div><div class="line"><span class="keyword">let</span> success = cal.nextWeekendStartDate(&amp;startDate, interval: &amp;interval, options: <span class="literal">nil</span>, afterDate: <span class="type">NSDate</span>())</div><div class="line"><span class="keyword">if</span> success, <span class="keyword">let</span> startDate = startDate &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"start: <span class="subst">\(startDate)</span>, interval: <span class="subst">\(interval)</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Swift化</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> nextWeekend = cal.nextWeekendAfterDate(<span class="type">NSDate</span>()) &#123;</div><div class="line">    <span class="built_in">println</span>(<span class="string">"start: <span class="subst">\(nextWeekend.startDate)</span>, interval: <span class="subst">\(nextWeekend.interval)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>这下复杂的日历计算吓不到你们了。有了 <code>NSCalendar</code> 提供的这些新功能，你可以很快的解决你碰到的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;日期.&lt;/em&gt; 一个很普通的时间和它的实现间往往有着巨大的差异，里面隐藏的多方面的复杂性远超其它数据类型。其中包括亚秒级的精度，重叠单元，不同地理位置的时区边界，语言和语法上的本地化差异，以及为了夏令时的转换和闰年调整，而在标准时间中添加删除整块的时间等等，里面有
    
    </summary>
    
    
      <category term="iOS" scheme="http://gwesley.tk/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Unexpected precedence issues with try? and as?</title>
    <link href="http://gwesley.tk/2016/12/20/test/"/>
    <id>http://gwesley.tk/2016/12/20/test/</id>
    <published>2016-12-20T06:19:12.000Z</published>
    <updated>2016-12-20T08:16:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Tim Vermeulen recently wrote on the Swift Evolution list that try? precedence can be unexpected:</p>
<pre><code class="swift"><span class="keyword">if</span> <span class="keyword">let</span> int = <span class="keyword">try</span>? mightReturnInt() <span class="keyword">as</span>? <span class="type">Int</span> {

 <span class="built_in">print</span>(int) <span class="comment">// =&gt; Optional(3)</span>

}
</code></pre>
<p>Specifically, he discovered that try?’s precedence is lower than as?’s precedence, so you may have to add parentheses to get the right result.</p>
<pre><code class="swift"><span class="keyword">if</span> <span class="keyword">let</span> int = (<span class="keyword">try</span>? mightReturnInt()) <span class="keyword">as</span>? <span class="type">Int</span> {
    <span class="built_in">print</span>(int) <span class="comment">// =&gt; 3</span>
}
</code></pre>
<p>He also found a similar issue with using try? on a throwing-optional-returning scenario:</p>
<pre><code class="swift"><span class="keyword">if</span> <span class="keyword">let</span> int = <span class="keyword">try</span>? mightReturnInt() {
    <span class="built_in">print</span>(int) <span class="comment">// =&gt; Optional(3)</span>
}

<span class="keyword">if</span> <span class="keyword">let</span> int = (<span class="keyword">try</span>? mightReturnInt()) ?? <span class="literal">nil</span> {
    <span class="built_in">print</span>(int) <span class="comment">// =&gt; 3</span>
}
</code></pre>
<p>There’s some magic baked into if let item = item as? T that automatically lifts optionals, which doesn’t yet seem to extend to try?. If you’re running into these situations, consider adding parentheses and nil-coalescing as demonstrated in these examples.</p>
<p>In case you think a throwing-optional scenario is too “out there”, think of a file system request that would throw on an unreadable directory and return nil if a specific file does not exist. Although obscure, it is not unthinkable to combine the two approaches.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tim Vermeulen recently wrote on the Swift Evolution list that try? precedence can be unexpected:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift&quot;&gt;&lt;span class
    
    </summary>
    
    
      <category term="iOS" scheme="http://gwesley.tk/tags/iOS/"/>
    
  </entry>
  
</feed>
